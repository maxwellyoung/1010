-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- PROFILES
create table public.profiles (
  id uuid references auth.users not null primary key,
  created_at timestamptz default now(),
  joined_at timestamptz,
  activation_date timestamptz,
  activated boolean default false,
  home_postcode text,
  last_seen_at timestamptz,
  last_known_tile text
);

alter table public.profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select using ( true );

create policy "Users can insert their own profile."
  on profiles for insert with check ( auth.uid() = id );

create policy "Users can update own profile."
  on profiles for update using ( auth.uid() = id );

-- PINGS (presence heartbeats)
create table public.pings (
  id bigint generated by default as identity primary key,
  profile_id uuid references public.profiles(id) on delete cascade,
  created_at timestamptz default now(),
  postcode text,
  tile text,
  lat double precision,
  lng double precision,
  source text default 'app'
);

alter table public.pings enable row level security;

create policy "Users can insert own pings."
  on pings for insert with check ( auth.uid() = profile_id );

create policy "Pings are viewable by everyone."
  on pings for select using ( true );

-- Index for fast recent ping queries
create index pings_recent_idx on pings (created_at desc) where postcode = '1010';
create index pings_profile_idx on pings (profile_id, created_at desc);

-- PRESENCE SIGNALS (realtime location for heat map)
create table public.presence_signals (
  id uuid default uuid_generate_v4() primary key,
  profile_id uuid references public.profiles(id) on delete cascade,
  created_at timestamptz default now(),
  expires_at timestamptz default now() + interval '15 minutes',
  lat double precision not null,
  lng double precision not null,
  tile text,
  intensity double precision default 1.0
);

alter table public.presence_signals enable row level security;

create policy "Users can insert own presence."
  on presence_signals for insert with check ( auth.uid() = profile_id );

create policy "Presence is viewable by everyone."
  on presence_signals for select using ( true );

create policy "Users can delete own presence."
  on presence_signals for delete using ( auth.uid() = profile_id );

-- Index for active presence queries
create index presence_active_idx on presence_signals (expires_at) where expires_at > now();

-- ENCOUNTERS (peer proximity events)
create table public.encounters (
  id uuid default uuid_generate_v4() primary key,
  profile_a uuid references public.profiles(id) on delete cascade,
  profile_b uuid references public.profiles(id) on delete cascade,
  created_at timestamptz default now(),
  lat double precision,
  lng double precision,
  duration_ms integer,
  max_resonance double precision,
  ritual_triggered boolean default false,
  encounter_hash text generated always as (
    case when profile_a < profile_b
      then profile_a::text || '-' || profile_b::text
      else profile_b::text || '-' || profile_a::text
    end
  ) stored
);

alter table public.encounters enable row level security;

create policy "Users can insert encounters they're part of."
  on encounters for insert with check ( auth.uid() = profile_a or auth.uid() = profile_b );

create policy "Users can view their own encounters."
  on encounters for select using ( auth.uid() = profile_a or auth.uid() = profile_b );

-- Index for encounter history
create index encounters_hash_idx on encounters (encounter_hash, created_at desc);
create index encounters_profile_idx on encounters (profile_a, created_at desc);

-- TRAILS (movement history)
create table public.trails (
  id uuid default uuid_generate_v4() primary key,
  profile_id uuid references public.profiles(id) on delete cascade,
  created_at timestamptz default now(),
  session_id uuid not null,
  lat double precision not null,
  lng double precision not null,
  accuracy double precision,
  seq integer not null
);

alter table public.trails enable row level security;

create policy "Users can insert own trails."
  on trails for insert with check ( auth.uid() = profile_id );

create policy "Users can view own trails."
  on trails for select using ( auth.uid() = profile_id );

-- Index for trail queries
create index trails_session_idx on trails (profile_id, session_id, seq);
create index trails_recent_idx on trails (profile_id, created_at desc);

-- WINDOW MOMENTS (shared serendipity events)
create table public.window_moments (
  id uuid default uuid_generate_v4() primary key,
  created_at timestamptz default now(),
  started_at timestamptz not null,
  ends_at timestamptz not null,
  position_x double precision not null,
  position_y double precision not null,
  triggered_by uuid references public.profiles(id),
  participant_count integer default 0
);

alter table public.window_moments enable row level security;

create policy "Anyone can view window moments."
  on window_moments for select using ( true );

create policy "Users can create window moments."
  on window_moments for insert with check ( auth.uid() = triggered_by );

-- PATTERN WALKS (user-created walking routes)
create table public.pattern_walks (
  id uuid default uuid_generate_v4() primary key,
  created_at timestamptz default now(),
  created_by uuid references public.profiles(id) on delete cascade,
  name text not null,
  description text,
  points jsonb not null, -- Array of {x, y, lat, lng, timestamp}
  duration_ms integer not null,
  distance_meters double precision not null,
  is_shared boolean default false,
  play_count integer default 0,
  zone_id text default 'auckland-1010'
);

alter table public.pattern_walks enable row level security;

create policy "Users can insert own walks."
  on pattern_walks for insert with check ( auth.uid() = created_by );

create policy "Users can view own walks."
  on pattern_walks for select using ( auth.uid() = created_by or is_shared = true );

create policy "Users can update own walks."
  on pattern_walks for update using ( auth.uid() = created_by );

create policy "Users can delete own walks."
  on pattern_walks for delete using ( auth.uid() = created_by );

-- Index for walk queries
create index pattern_walks_user_idx on pattern_walks (created_by, created_at desc);
create index pattern_walks_shared_idx on pattern_walks (is_shared, zone_id) where is_shared = true;

-- NETWORK STATS VIEW (optimized)
create or replace view network_stats as
select
  count(distinct profile_id) as total_participants,
  count(distinct case when created_at > now() - interval '24 hours' then profile_id end) as active_last_24h,
  count(distinct case when created_at > now() - interval '1 hour' then profile_id end) as active_last_hour,
  coalesce(
    least(4, ceil(count(case when created_at > now() - interval '15 minutes' then 1 end)::numeric / 3)),
    0
  ) as ping_density
from pings
where postcode = '1010';

-- PRESENCE DENSITY VIEW (for heat map)
create or replace view presence_density as
select
  tile,
  count(*) as signal_count,
  avg(intensity) as avg_intensity,
  max(created_at) as last_signal
from presence_signals
where expires_at > now()
group by tile;

-- ENCOUNTER FREQUENCY VIEW (for resonance threads)
create or replace view encounter_frequency as
select
  encounter_hash,
  count(*) as encounter_count,
  max(created_at) as last_encounter,
  bool_or(ritual_triggered) as has_ritual
from encounters
group by encounter_hash
having count(*) >= 2;

-- Function to clean expired data
create or replace function cleanup_expired_data()
returns void as $$
begin
  delete from presence_signals where expires_at < now();
  delete from pings where created_at < now() - interval '30 days';
  delete from trails where created_at < now() - interval '7 days';
end;
$$ language plpgsql security definer;

-- Function to get nearby presence for heat map
create or replace function get_nearby_presence(
  user_lat double precision,
  user_lng double precision,
  radius_km double precision default 0.5
)
returns table (
  id uuid,
  lat double precision,
  lng double precision,
  intensity double precision,
  age_minutes integer
) as $$
begin
  return query
  select
    ps.id,
    ps.lat,
    ps.lng,
    ps.intensity,
    extract(epoch from (now() - ps.created_at))::integer / 60 as age_minutes
  from presence_signals ps
  where ps.expires_at > now()
    and (
      6371 * acos(
        cos(radians(user_lat)) * cos(radians(ps.lat)) *
        cos(radians(ps.lng) - radians(user_lng)) +
        sin(radians(user_lat)) * sin(radians(ps.lat))
      )
    ) < radius_km
  order by ps.created_at desc
  limit 20;
end;
$$ language plpgsql security definer;
